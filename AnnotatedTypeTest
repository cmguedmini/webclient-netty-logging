package com.example.reflection; // Assurez-vous d'avoir la bonne structure de package

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import java.lang.reflect.AnnotatedArrayType;
import java.lang.reflect.AnnotatedType;
import java.lang.reflect.AnnotatedTypeVariable;
import java.lang.reflect.Method;
import java.util.List;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Version simplifiée des tests pour AnnotatedTypeHelper, utilisant la réflexion
 * réelle sur une classe de référence pour générer les AnnotatedType.
 */
class AnnotatedTypeHelperTest {

    // --- Classe de Référence (pour générer tous les types AnnotatedType via la réflexion) ---
    
    // T est une TypeVariable
    // List<String> est un AnnotatedParameterizedType
    // E[] est un AnnotatedArrayType (si E est un type variable)
    // ? extends Number est un AnnotatedWildcardType
    static class ReferenceClass<T> {
        public List<String> parameterizedTypeMethod() { return null; }
        public T typeVariableMethod() { return null; }
        public T[] arrayTypeMethod() { return null; }
        public List<? extends Number> wildcardTypeMethod() { return null; }
        public String simpleTypeMethod() { return null; } // Pour le cas non géré
    }

    // --- Méthode Utile pour la Réflexion ---

    /** Obtient l'AnnotatedType de retour d'une méthode spécifique. */
    private AnnotatedType getAnnotatedReturnType(String methodName) throws NoSuchMethodException {
        Method method = ReferenceClass.class.getMethod(methodName);
        return method.getAnnotatedReturnType();
    }

    // --- Tests Uniques pour chaque Type ---

    @Test
    @DisplayName("Devrait retourner les arguments de type pour AnnotatedParameterizedType (List<String>)")
    void getAnnotatedTypeParameter_whenParameterizedType_shouldReturnTypeArguments() throws NoSuchMethodException {
        // ARRANGE
        AnnotatedType type = getAnnotatedReturnType("parameterizedTypeMethod"); // Vrai AnnotatedParameterizedType

        // ACT
        AnnotatedType[] result = AnnotatedTypeHelper.getAnnotatedTypeParameter(type);

        // ASSERT
        // List<String> a un seul argument : String
        assertNotNull(result, "Le résultat ne devrait pas être null.");
        assertEquals(1, result.length, "Devrait trouver l'argument de type 'String'.");
        // Vérifie si le type retourné est effectivement 'String' (ou sa représentation Annotated)
        assertEquals(String.class, result[0].getType(), "L'argument de type devrait être String.");
    }

    @Test
    @DisplayName("Devrait retourner les bornes pour AnnotatedTypeVariable (T)")
    void getAnnotatedTypeParameter_whenTypeVariable_shouldReturnBounds() throws NoSuchMethodException {
        // ARRANGE
        AnnotatedType type = getAnnotatedReturnType("typeVariableMethod"); // Vrai AnnotatedTypeVariable
        
        // ACT
        AnnotatedType[] result = AnnotatedTypeHelper.getAnnotatedTypeParameter(type);

        // ASSERT
        // T a une seule borne par défaut : Object
        assertNotNull(result, "Le résultat ne devrait pas être null.");
        assertEquals(1, result.length, "Devrait trouver la borne par défaut 'Object'.");
        // Le résultat est le tableau des bornes (AnnotatedTypeVariable.getAnnotatedBounds())
        assertTrue(type instanceof AnnotatedTypeVariable, "Le type doit être AnnotatedTypeVariable.");
        assertArrayEquals(((AnnotatedTypeVariable) type).getAnnotatedBounds(), result, 
                          "Devrait retourner les bornes Annotated (Object).");
    }

    @Test
    @DisplayName("Devrait gérer la récursivité pour AnnotatedArrayType (T[])")
    void getAnnotatedTypeParameter_whenArrayType_shouldRecurse() throws NoSuchMethodException {
        // ARRANGE
        AnnotatedType type = getAnnotatedReturnType("arrayTypeMethod"); // Vrai AnnotatedArrayType<T>

        // ACT
        AnnotatedType[] result = AnnotatedTypeHelper.getAnnotatedTypeParameter(type);

        // ASSERT
        // Un tableau T[] récursive sur T (AnnotatedTypeVariable).
        // Le résultat devrait être les bornes de T (qui est Object par défaut).
        assertTrue(type instanceof AnnotatedArrayType, "Le type doit être AnnotatedArrayType.");
        assertNotNull(result, "Le résultat ne devrait pas être null.");
        assertEquals(1, result.length, "Devrait trouver les bornes de l'élément (Object).");
        assertEquals(Object.class, result[0].getType(), "La borne récursive devrait être Object.");
    }

    @Test
    @DisplayName("Devrait retourner les bornes supérieures pour AnnotatedWildcardType (List<? extends Number>)")
    void getAnnotatedTypeParameter_whenWildcardType_shouldReturnUpperBounds() throws NoSuchMethodException {
        // ARRANGE
        // AnnotatedParameterizedType -> AnnotatedWildcardType
        AnnotatedType parameterizedType = getAnnotatedReturnType("wildcardTypeMethod"); 
        
        // Extrait le AnnotatedWildcardType réel de la List (List a 1 argument)
        AnnotatedType wildcardType = ((java.lang.reflect.AnnotatedParameterizedType) parameterizedType)
                                        .getAnnotatedActualTypeArguments()[0];
        
        // ACT
        AnnotatedType[] result = AnnotatedTypeHelper.getAnnotatedTypeParameter(wildcardType);

        // ASSERT
        // ? extends Number a une seule borne supérieure : Number
        assertTrue(wildcardType instanceof java.lang.reflect.AnnotatedWildcardType, "Le type doit être AnnotatedWildcardType.");
        assertNotNull(result, "Le résultat ne devrait pas être null.");
        assertEquals(1, result.length, "Devrait trouver la borne supérieure 'Number'.");
        assertEquals(Number.class, result[0].getType(), "La borne supérieure devrait être Number.");
    }
    
    @Test
    @DisplayName("Devrait retourner un tableau vide pour un type non géré (String)")
    void getAnnotatedTypeParameter_whenUnhandledType_shouldReturnEmptyArray() throws NoSuchMethodException {
        // ARRANGE
        AnnotatedType type = getAnnotatedReturnType("simpleTypeMethod"); // Vrai AnnotatedType (pas une instance gérée)

        // ACT
        AnnotatedType[] result = AnnotatedTypeHelper.getAnnotatedTypeParameter(type);

        // ASSERT
        assertNotNull(result, "Le résultat ne devrait pas être null.");
        assertEquals(0, result.length, "Devrait retourner un tableau vide pour les types non gérés.");
    }
}
